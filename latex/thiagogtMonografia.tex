


\documentclass[a4paper,10pt]{article}
%\documentclass[a4paper,10pt]{scrartcl}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{subfig}
\usepackage{setspace}
\usepackage{geometry}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\usepackage{xcolor}
\usepackage{cite}  % Needed to use citations.  
\definecolor{verde}{rgb}{0.25,0.5,0.35}
\definecolor{jpurple}{rgb}{0.5,0,0.35}
\usepackage{listings}
\usepackage{float}

\lstset{
  language=Java,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{jpurple}\bfseries,
  stringstyle=\color{red},
  commentstyle=\color{verde},
  morecomment=[s][\color{blue}]{/**}{*/},
  extendedchars=true,
  showspaces=false,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  breaklines=true,
  backgroundcolor=\color{cyan!10},
  breakautoindent=true,
  captionpos=b,
  xleftmargin=0pt,
  tabsize=4
}
\pagestyle{empty}
% Formatação
\topmargin -1.5cm
\oddsidemargin -0.04cm
\evensidemargin -0.04cm
\textwidth 16.59cm
\textheight 21.94cm 


\pdfinfo{%
  /Title    ()
  /Author   ()
  /Creator  ()
  /Producer ()
  /Subject  ()
  /Keywords ()
}

\begin{document}

\begin{titlepage}

\begin{center}
\includegraphics[width=0.15\textwidth]{./imgs/IME.png}\\[1cm]
\textsc{\Large Instituto de Matemática e Estatística\\ Universidade de São Paulo}\\[0.5cm]
{\large Bacharelado em Ciências da Computação}\\[5.0cm]
\HRule \\[0.4cm]
{\huge \bfseries Library Mapper} 
\HRule \\[1.0cm]

\begin{flushleft} \large
{\large Thiago Gomes Toledo\\ Supervisor: Prof. Dr. Marcelo Finger}
\end{flushleft}
\vfill

{\large São Paulo - SP\\[0.5cm] Segundo semestre de 2011}
\end{center}
\end{titlepage}

\newpage

\textit{ Agradeço a minha mãe Mara Lucia Gomes Toledo e a meu pai João Batista Toledo por terem me dado a oportunidade de realizar 
meu sonho; A OPUS-Software por proporcionar diversos recursos para a realização desse sonho; A minha esposa Lucianna Thomaz Almeida Toledo por me dar conforto, ajuda e sábias dicas; A meu filho que me traz
alegria só por imaginar seu rosto e a Deus por ter me dado todos e tudo que sempre precisei.}


\footnote[1]{Para mais informações sobre essa monografia, apresentação, código, etc.. acesse o site: \href{''http://www.linux.ime.usp.br/~renoir/mac499/proposta.html''}{www.linux.ime.usp.br/~renoir/mac499/proposta.html}}
\newpage
 \tableofcontents
\newpage
    \section{Introdução}
   
    Como frequentador da biblioteca do Instituto de Matemática e 
    Estatística da USP desde 2008 e trabalhando na biblioteca do Instituto de Geociencias da USP em 2010-2012, 
    pude notar que as reclamações numa biblioteca sobre a dificuldade em se achar um livro lideram o ranking de 
    problemas apontados por visitantes que usualmente têm que apelar para a boa vontade dos funcionários, 
    pois acham muito complicado ou até sem nenhum sentido o modo como as fileiras de livros são identificadas.\\
    
    Em ambos os casos os alunos ainda eram capazes de encontrar seus livros ou teses dado que a maior delas possuia
    não mais que 20.000 exemplares.Contudo, numa biblioteca como a da Faculdade de Filosofia, Letras e Ciências Humanas
    que hoje possui um inventório de mais de 500 mil livros e ainda 600 mil teses\footnote[1]{Dados levantados em janeiro 2012 com a diretora da biblioteca, Maria Aparecida Laet}, a busca se torna completamente inviável
    sem nenhum auxílio real.\\
   
    
    \section{Parte Objetiva}
    Nessa parte do texto, serão apresentados os conceitos teóricos do trabalho, além da parte prática
    de desenvolvimento.

    \subsection{Objetivo}
    Com uma ferramenta que mostre como ir do ponto onde está o visitante até o livro através de um mapa, esse dificilmente se sentiria perdido 
    ou precisaria contar com o auxílio de terceiros.Portanto, o objetivo desse projeto Library Mapper é que o vistante
    busque, escolha o livro e receba no seu aparelho mobile um mapa com o caminho correto até esse livro.
    
    \subsection{Problema}

    Como dispositivos GPS não mapeam dentro de residências, é inviável utilizar a Geolocalização do visitante para qualquer fim e portanto
    era necessário criar algum método para identificar onde ele estava localizado, como era esse lugar e como gerar uma busca
    entre onde ele estava e onde devia chegar.
    
    
    \subsection{Solução}
    
  Inicialmente desenvolvida para dispositivos IOS, essa ferramenta utiliza tags com códigos QR para auxiliar 
  o reconhecimento da localização atual do visitante.\\

  O visitante ao entrar numa biblioteca procura essa tag e com seu dispositivo IOS, reconhece o código 
  nela contido.Esse código abre um Web Browser no dispositivo e uma página da biblioteca na internet é 
  mostrada na tela.O visitante digita o livro num campo de busca e uma vez que esse existe nessa biblioteca, 
  a tela do web browser é substituída por uma tela com um mapa que mostra o caminho da tag selecionada 
  até a fileira onde esta o livro.\\
  
   Para ser possível a localização do livro, será utilizada a prévia catalogação feita pela biblioteca da 
   posição do mesmo e uma réplica proporcional do mapa real da biblioteca .Essa réplica
   é desenvolvida através de uma plataforma web que gera mapas 2D também desenvolvida nesse projeto.As informações
   obtidas nesse mapa, localização de estantes e suas correspondentes identificações, Qr-Codes, obstáculos e limites
   da biblioteca, serão enviados e armazenados num banco de dados da aplicação.\\
   
   
   
   
   O mapa será gerado num grafo tipo grid e cada nó está dividido em 4 tipos principais que são QR-Code, Forbidden, Free e Bookshelf 
   numa classe Node e será baseado nesses tipos que a busca pelo livro dado será feita.\\

   Como todas as arestas destre grafo tem peso único um, o algoritmo de busca usado é uma Bi-direcional BFS (Breadth-first search) com uma busca saindo da origem(QR-Code
   selecionado pelo visitante) e outra do destino (estante onde está o livro).\\

Essa busca é feita de uma maneira paralela onde cada thread é um dos pólos do caminho Bi-direcional.\\ 
  
    \subsection{Conceitos e tecnologias estudadas}
	\begin{figure}[H]
	\centering
      	\includegraphics[width=0.70\textwidth]{./imgs/esquemaLibrary.png}
	\caption{Técnologias usadas}
	
      \end{figure}

	
      \subsubsection{O que são Qr-Codes?}
      Quick Response Code foi inventado por \href{http://www.denso-wave.com/}{DENSO WAVE}, uma empresa Japonesa de captura automática de dados, FA e campos de solução de negócios, em 1994 e foi um dos primeiros códigos de barra 2D
      a ser usado em aplicações onde era necessário uma combinação de camera de aparelhos celulares e códigos de barra 2D.\cite{barcode}Esses códigos trocam barras e espaços
      por pontos e espaços arranjados num vetor ou uma matrix, aumentando consideravelmente a quantidade de dados
      armazenados num espaço igualmente usado para um código de barra 1D.\\

      Apenas em 2002 cameras de celulares foram comercialmente vendidas com dispositivos reconhecedores de Qr-codes e desde
      então uma vasta variedade de aplicativos começou a surgir no Japão e vem tomando o mundo.
	\begin{figure}[H]
	\centering

      \includegraphics[width=0.20\textwidth]{./imgs/qrcode.png} 
      \end{figure}
	Em 2006, como parte do Windows Live service, a Microsoft lançou o Windows Live Barcode
      , onde Qr-codes eram usados como ponte para troca de informações entre aparelhos mobile e outras medias como PCs, Tv de plasma
      e revistas.\\
      
      As Qr-Codes geradas para esse projeto passarão para o usuário o endereço de uma página web de busca dos livros da 
      bilioteca em que ele se encontra.Junto nessa URL tem um id do Qr-Code, que mostra para o programa onde no grafo
      do mapa da biblioteca se encontra o visitante, para dessa maneira poder criar o caminho que o mesmo deve traçar.\\
      
      
      
      \subsubsection{Grid Graphs}
      
      Um grafo \textit{G} é uma par \textit{(V,E)}, onde \textit{V} é um conjunto finito e \textit{E} é uma relação binária de \textit{V}.
      O conjunto \textit{V} é chamado de o \textit{conjunto de vértices} de \textit{G} e seus elementos são chamados 
      de \textit{vértices}.O conjunto \textit{E} é chamado de \textit{conjunto de arestas} de \textit{G} e seus elementos
      são chamados de \textit{arestas}.Existem dois tipos de grafos - grafo direcionados e grafos não-direcionados.
            \cite{bfs}\\
      
      Uma aresta num \textit{grafo não-direcionado} é um conjunto \textit{\{u,v\}} onde \textit{u,v} $\in$ \textit{V} e \textit{u $\neq$ v} que por
      convenção é definida como \textit{$(u,v)$} ou \textit{$(v,u)$} e é possível ir de \textit{u} para \textit{v} e de \textit{v} 
      para \textit{u}.\\
      
      Já num \textit{grafo direcionado} (ou \textit{dígrafo} ) uma aresta é identificada por setas e \textit{$(u,v)$} \textit{$\neq$} \textit{$(v,u)$}.
      
     \begin{figure}[H]
	\centering
      	\includegraphics[width=0.7\textwidth]{./imgs/grafo.png}\\[1cm]
      	\caption{Grafo retirado do livro \cite{bfs}}
      \end{figure}
      Em ambos os casos uma aresta \textit{(u,v)} pode possuir um \textit{peso} que indica o custo por passar do vértice \textit{u}
      para o \textit{v}.\\
      
      Um Grid Graph ( grafo do tipo Grid ) é um grafo não-direcionado; uma grade de nós (vértices) \textit{n} x \textit{n} sendo que cada
      nó tem exatamente 4 arestas com exceção dos nós das extremidades.
       \begin{figure}[H]
	\centering
      \includegraphics[width=0.5\textwidth]{./imgs/grid.png}\\[1cm]
	\caption{Representação de um Grid}
      \end{figure}
      Para o LibraryMapper será usado um grafo não-direcinado do tipo Grid alocado numa matriz, sendo que cada vértice do grafo 
      será um nó da classe Node.Essa Possui os seguintes atributos:\\
      
      
      \begin{lstlisting}
package library.domain;

public class Node {
    
    private Integer idNode;
    private Integer positionX;
    private Integer positionY;
    private Integer contentId;
    private Integer idLibrary;
    private String codeIdInitialShelf;
    private String codeIdFinalShelf;t
    private String contentType;//Free,QrCode,Forbidden,Shelf
    private Node parentFromBeginNode;
    private Node parentFromEndNode;
    public int isInUse;
    private Semaphore semaphore;
    private String color;
    private String whoMarkedThisNode;
/*... continua ...*/
\end{lstlisting}
\vspace{1cm}
{\bf idNode:} o id de cada novo Node. \\
{\bf positionX: }coluna j na matriz Mapa(i,j)\footnote{A matriz que se refere ao mapa da biblioteca}      . \\
{\bf positionY: }linha i na matriz Mapa(i,j).\\
{\bf contentsType:} Tipo do Node, podendo variar entre Free, Forbidden, QrCode ou Shelf.\\
{\bf contentsId: }Uma vez definido qual o tipo do Node é necessário saber qual o seu id na tabela relacionada.Caso não possua uam tabela, como é o caso
 de Free e Forbidden, o ContentsId é um valor desnecessário\\
{\bf idLibrary:} o id da biblioteca a qual pertence.\\
{\bf codeIdInitialShelf: }o identificador inicial de uma estante\\
{\bf codeIdFinalShelf:}o identificador final de uma estante\\
{\bf parentFromBeginNode:}o nó pai do nó atual na busca feita partindo do ponto inicial definido \\
{\bf parentFromEndNode:}o nó pai do nó atual na busca feita partindo do ponto final definido\\
{\bf isInUse:}flag que define se o nó em questão está sendo usado por outro processo de busca.\\
{\bf semaphore:} semáforo do nó.\\
{\bf color:} cor do nó definida no esquema da BFS.\\
{\bf whoMarkedThisNode:} valor que define qual busca já passou por esse nó.\\


      Alguns atributos serão melhores descritos nas próximas seções.\\
      
      
      \subsubsection{Breadth-First Search (BFS)}
      Dado um grafo \textit{G=(V,E)} com um vértice \textit{s} distinto, Breadth-first search explora sistematicamente
      as arestas de \textit{G} para descobrir todo vértice que pode ser alcançado por \textit{s}.Ele computa a distância
      (menor número de arestas) do vértice \textit{s} até todos os vértices que ele possa alcançar.Para manter o controle do progresso da busca, BFS procura cores em cada vértice - branco, cinza e preto. Todos os 
      vértices começam com cor branca, eventualmente passam para cinza e por fim  ficam pretos.\cite{bfs}\\
      
      Uma vez que um vértice é descoberto ele se torna não-branco.Um vértice só se tornará preto quando todos os vértices
      que são adjacentes á ele tenham sido descobertos, enquanto isso ele será cinza.Isso representa a fronteira entre
      vértices descobertos e não-descobertos como mostrado na Figura~\ref{./imgs/bfs.png}\\
	
	Como no pior caso, a busca tem que ser feita em todos os (m) nós de um grafo e passar por todas suas (a) arestas.Como a 
      BFS não volta nos caminhos que já traçou, a complexidade desse algoritmo é O(a).\\	 
      \begin{figure}[H]
	\centering
      	\includegraphics[width=0.50\textwidth]{./imgs/bfs.png}
	\caption{BFS retirada do livro \cite{bfs}}
	\label{./imgs/bfs.png}
      \end{figure}
      Além das cores, nesse projeto essa BFS distingue entre nós (vértices) do tipo Free, Bookshelf, Qr-Code e Forbidden e será 
      aplicada de uma maneira Bi-direcional.\\
      
      \subsubsection{Bi-directional BFS}
	A idéia por trás de uma busca Bi-direcional é fazer duas buscas rodarem simultaneamente - Uma "para frente", 	 
	saindo do estado inicial (a origem) da busca inteira e outra "para trás",  saindo do estado final ( a chegada ) 
	da busca inteira esperando que ambas se encotrem no meio.\cite{bidirecional}. 
 	\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{./imgs/bi-directional.png}\\[1cm]   
	\caption{BFS bi-direcional retirada do livro \cite{bidirecional}}
      	\end{figure}
	Nesse projeto a busca Bi-direcional será realizada através de métodos concorrentes de programação.Cada pólo
	iniciará sua busca paralelamente liberando assim duas threads.Caso uma thread chegue em um nó que já foi 
	visitado ela define aquele nó como o "meio do caminho" e a partir dele gera a rota inteira do mapa.Mas caso o nó que
	chegue esteja sendo visitado, ela para e abandona o que estiver fazendo para depois ser reciclada num outro novo processo.
	Nas próximas seções serão demonstradas com maiores detalhes, como essa busca foi implementada no Library Mapper.\\
 
	Pela profundidade da busca ter caído pela metade, ou seja, no máximo uma busca tem que ir até a metade do grafo, a 
	complexidade do algoritmo é O(a/2).\\
	

	
	
	\subsubsection{pgAdmin - Interface gráfica para gerenciamento do banco de dados PostgreSQL}
	{\it	pgAdmin é o recurso de administração Open-Source para o banco de dados PostgreSQL. O aplicativo 
	pode ser usado no Linux, FreeBSD, Solaris, Mac OSX e Windows para gerenciar o PostgreSQL 7.3 e acima executado em qualquer
	 plataforma, bem como versões comerciais e derivados do PostgreSQL como Postgres Plus avançado Server e banco de dados Greenplum.\\
	
	pgAdmin é projetado para atender as necessidades de todos os usuários, desde escrever consultas SQL simples para o 
	desenvolvimento de bancos de dados complexos. A interface gráfica suporta todos os recursos do PostgreSQL e facilita
	 a administração. O aplicativo também inclui um destaque de sintaxe SQL editor, um editor de código do lado do servidor, 
	um agente de agendamento de tarefas SQL/batch/shell,etc. Conexão com o servidor pode ser feita usando TCP / IP ou soquetes
	 de domínio Unix (nas plataformas * nix), e pode ser criptografado SSL para a segurança. Drivers adicionais não são necessários
	 para se comunicar com o servidor de banco de dados.}\cite{pgAdmin}\\

	
	Com o pgAdmin não é possível iniciar um servidor de Banco de dados no linux. É necessário um terminal para criar
	 e configurar um servidor de banco de dados e referenciá-lo no pgAdmin.Contudo uma vez isso feito, fica fácil
	 criar banco de dados e também editar, deletar tabelas e colunas desse banco.Como exemplo, a figura \ref{telaPgAdmin} mostra como 
	é a tela de administração dos bancos de dados em conjunto de uma das tabelas do banco do Library Mapper.\\ 
	
	No Library Mapper foi criado um banco de dados com o nome libraryMapperBD que utiliza a porta padrão do servidor de dados para se comunicar com o programa.
	Os detalhes desse banco serão vistos logo em seguida.\\

	\subsubsection{PostgreSQL}
	{\it O PostgreSQL é um poderoso sistema gerenciador de banco de dados objeto-relacional de código aberto.  
	Tem mais de 15 anos de desenvolvimento ativo e uma arquitetura que comprovadamente ganhou forte reputação 
	de confiabilidade, integridade de dados e conformidade a padrões.  Roda em todos os grandes sistemas operacionais, 
	incluindo GNU/Linux, Unix (AIX, BSD, HP-UX, SGI IRIX, Mac OS X, Solaris, Tru64), e MS Windows. É totalmente compatível
	 com ACID, tem suporte completo a chaves estrangeiras, junções (JOINs), visões, gatilhos e procedimentos armazenados
	 (em múltiplas linguagens).  Inclui a maior parte dos tipos de dados do ISO SQL:1999, incluindo INTEGER, NUMERIC, BOOLEAN, 
	CHAR, VARCHAR, DATE, INTERVAL, e TIMESTAMP.  Suporta também o armazenamento de objetos binários, incluindo figuras, sons ou
	 vídeos.  Possui interfaces nativas de programação para C/C++, Java, .Net, Perl, Python, Ruby, Tcl, ODBC, entre outros, e 
	uma excepcional documentação.}


	\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{./imgs/pgAdminLibrary.png}\\[1cm]   
	\caption{tela de administração pgAdmin e tabela de dados}
	\label{telaPgAdmin}
      	\end{figure}
		
	{\it Como um banco de dados de nível corporativo, o PostgreSQL  possui funcionalidades sofisticadas como o controle de concorrência 
	multiversionado (MVCC, em inglês), recuperação em um ponto no tempo (PITR em inglês), tablespaces, replicação assíncrona, transações
	 agrupadas (savepoints), cópias de segurança a quente (online/hot backup), um sofisticado planejador de consultas (otimizador) e registrador 
	de transações sequencial (WAL) para tolerância a falhas.  Suporta conjuntos de caracteres internacionais, codificação de caracteres multibyte, 
	Unicode e sua ordenação por localização, sensibilidade a caixa (maiúsculas e minúsculas) e formatação.  É altamente escalável, tanto na quantidade
	 enorme de dados que pode gerenciar, quanto no número de usuários concorrentes que pode acomodar. Existem sistemas ativos com o PostgreSQL em
	 ambiente de produção que gerenciam mais de 4TB de dados.  Alguns limites do PostgreSQL estão incluídos na tabela abaixo.}\cite{postgresql}
	
	\begin{table}[H]
 	\centering
	\begin{tabular}{|l|c|} \hline
		Tamanho Máximo do Banco de Dados &  ilimitado\\ \hline
		Tamanho máximo de uma Tabela  &	32 TB\\ \hline
		Tamanho Máximo de uma Linha &	1.6 TB\\ \hline
		Tamanho Máximo de um Campo  & 	1 GB\\ \hline
		Máximo de Linhas por Tabela &	Ilimitado\\ \hline
		Máximo de Colunas por Tabela & 	250–1600 dependendo do tipo de coluna\\ \hline
Máximo de Índices por Tabela & 	Ilimitado\\ \hline
	\end{tabular}
	\caption{Dados retirados do site \href{http://www.postgresql.org.br/sobre}{PostgreSQL}}
	\label{t_fixa}
\end{table}	
	O banco de dados usado pelo Library Mapper é criado para armazenar a matriz que se refere ao mapa da biblioteca, 
	representada aqui por Mapa(i,j).\\O banco contém 4 tabelas:
\begin{itemize}
\item{library}\\[0.3cm]
\includegraphics[width=0.20\textwidth]{./imgs/librayBD.png} 

Essa tabela foi criada para o cliente ter liberdade de criar inúmeras versões de bibliotecas e também carregá-las quando queira.\\

idLibrary: o id de cada nova biblioteca criada.\\
size\_X: número de colunas na matriz Mapa(i,j).\\
size\_Y: número de linhas na matriz Mapa(i,j).\\


\item{node}\\[0.3cm]	
\includegraphics[width=0.30\textwidth]{./imgs/nodeBD.png}\\

Cada Node equivale a uma posição na matriz Mapa(i,j)

idNode: o id de cada novo Node. \\
positionX: coluna j na matriz Mapa(i,j). \\
positionY: linha i na matriz Mapa(i,j).\\
contentsType: Tipo do Node, podendo variar entre Free, Forbidden, QrCode ou Shelf.\\
contentsId: Uma vez definido qual o tipo do Node é necessário saber qual o seu id na tabela relacionada.Caso não possua uam tabela, como é o caso
 de Free e Forbidden, o ContentsId é um valor desnecessário\\
idLibrary: o id da biblioteca a qual pertence.\\\\

\item{bookshelf}\\[0.3cm]
\includegraphics[width=0.30\textwidth]{./imgs/bookShelfBD.png}\\	

Quando uma bookshelf é criada ela recebe dois identificadores, sendo um referente ao primeiro livro contido nela e o outro o último.Dessa maneira, é possível
identificar o range de livros contido nela.Mas para ser possível fazer uma busca no banco de dados nesse range, é necessário retirar dois
valores inteiros, sendo um o início e o outro o fim do range.Por isso a tabela bookshelf divide os identificadores em 3 partes: prefixo ,codeId
e versão.Dessa maneira, com a identificação do prefixo mais a verificação no range da estante, é possível retornar uma consulta precisa da estante
que se encontra o livro.A figura \ref{parser} mostra a maneira como uma das duas indentificações é dividida para ser guardada no banco de dados.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.40\textwidth]{./imgs/estanteParseada.png}\\[1cm]   
	\caption{Identificação da estante parseada.}
	\label{parser}
\end{figure}

idBookShelf: o  id de cada nova estante\\
idLibrary: o id da biblioteca a qual pertence.\\
prefixCodeIdInitial: prefixo incial da estante\\
codeIdInitial:range inicial da estante\\
versionCodeIdInitial:versão inicial da estante\\
prefixCodeIdFinal:prefixo final da estante\\
codeIdFinal:range final da estante\\
versionCodeIdFinal:versão final da estante
\item{qr\_cod\_mark}\\[0.3cm]

\includegraphics[width=0.20\textwidth]{./imgs/qrCodeBD.png}\\	

idQrMark: id de cada novo QrCode\\
url: a url contida no QrCode.\\
idLibrary:o id da biblioteca a qual esse QrCode pertence\\
\end{itemize}
	A imagem abaixo ilustra o banco de dados completo.
\begin{figure}[H]
	\centering

	\includegraphics[width=0.70\textwidth]{./imgs/merLibraryMappper.png}\\[1cm]	
	\caption{Identificação da estante parseada.}
	\label{total}
\end{figure}

	\subsubsection{Mybatis - Mapeando SQL para JAVA}
	
	Uma vez criado o banco de dados, é necessário criar métodos que permitam operar nesse BD.Contudo, para isso ser possível
	é necessário fazer consultas em SQL no BD da aplicação, a qual está toda escrita em linguagem JAVA.Isso não é um grande 
	problema, mas consome tempo e pasciência do programador que terá que fazer vários ajustes e códigos extras em JDBC.
	(JDBC ou Java Database Connectivity é um conjunto de Classes e interfaces em JAVA, que conversam com qualquer Banco de dados através 
	de envio de intruções SQL.)
	
	{\it MyBatis é um framework de persistência de primeira classe, com 
	suporte para SQL personalizado, procedimentos armazenados e mapeamentos avançados. 
	MyBatis elimina quase todo o código JDBC e ajuste manual dos parâmetros e recuperação 
	de resultados. MyBatis pode usar XML simples ou Anotações para configuração e mapa primitivas,
	 interfaces e POJOs Mapa Java (Plain Old Java Objects) para registros de dados.}\cite{mybatis}\\

	No Library Mapper ainda foi usado uma ferramenta do Eclipse chamada {\it MyBatis Generator} que monta todo o mapeamento 
	feito pelo Mybatis direto no projeto.Ao configurar dois arquivos, generatorConfig.xml e MapperConfig.xml, setando quais as
	tabelas deveriam ser mapeadas para suas futuras classes no Library Mapper, tudo é gerado automaticamente pela ferramenta.\\

	O mapeamento consiste em três partes:\\
	\begin{itemize}
	\item{As Classes Domínio}\\
	Essas são as classes correspondentes aos atributos do Banco de Dados.Necessariamente todas as colunas de um BD têm 
	que estar relacionadas a um atributo dessas classes, mas o contrário não é verdade.Quando um select é feito com as interfaces Mapas
	descritas abaixo, um objeto de um dos domínios é retornado.\\

	Library.java, BookShelf.java, Node.java e QrCodeMark.java são as classes domínio no Library Mapper.\\

	\item{As interfaces Mapas}\\
	Essas são as interfaces JAVA com o métodos de consultas SQL e são elas que serão usadas pelo programador para fazer uma consulta
	no banco de dados.Essas interfaces chamam os métodos implementados nos XMLs, descritos abaixo.\\
		
	LibraryMapper.java, BookShelfMapper.java, NodeMapper.java e QrCodeMarkMapper.java são as interface Mapas no Library Mapper.\\
	\item{Os XMLs}\\
	Essas são as consultas com linguagem parcialmente SQL.Essas são as consultas mais próximas a uma linguagem SQL e são elas que são
	usadas nos Bancos de Dados.Todas as consultas desses arquivos têm o mesmo nome que os métodos das interfaces Mapas.\\

	LibraryMapper.xml, BookShelfMapper.xml, NodeMapper.xml e QrCodeMarkMapper.xml são os XMLs de consulta do Library Mapper.\\
	\end{itemize}
	
	Uma vez gerado todo o mapeamento, basta criar uma nova seção e começar a usar os métodos da interface Mapas.
	

	\subsubsection{JSP, Servlets e Apache Tomcat}


	{\it A tecnologia JavaServer Pages (JSP) permite que os desenvolvedores da Web e
	 designers desenvolvam e mantenham de uma maneira fácil e rápida páginas Web dinâmicas 
	. Como parte da família da tecnologia Java, a tecnologia JSP permite o rápido desenvolvimento
	 de aplicações baseadas na Web que são independentes de plataforma. A tecnologia JSP separa
	 a interface do usuário a partir de geração de conteúdo, permitindo aos designers para alterar
	 o layout geral da página sem alterar o conteúdo dinâmico subjacente. JavaServer Pages é uma extensão 
	da tecnologia Java Servlet.\\
	
	 Servlets são independentes de plataformas, são módulos que se encaixam perfeitamente em 
	uma estrutura de servidor Web e podem ser usados para estender
	 as capacidades de um servidor Web com mínima sobrecarga, manutenção e suporte. Ao contrário de outras linguagens de
	 script, servlets não envolvem nenhuma consideração específica da plataforma ou modificações, que são componentes de
	 aplicativos que são baixados, a pedido, para a parte do sistema que precisa deles.}\cite{jsp}\\

	Apache Tomcat é uma implementação open source do Java Servlet e JavaServer Pages, responsável por manter as páginas do Library Mapper
	na internet.
	
	\subsubsection{JSF2 - Managed Beans}
	O JavaService Facelets 2 oferece muitos recursos para o desenvolvimento de uma aplicação Web Java, sendo um dos principais os Managed Beans que são
	objetos utilizados para:
		{\it\begin{itemize}
	\item{Receber os dados enviados pelos usuários através das telas Web da aplicação.}
	\item{Executar as lógicas para tratar as requisições dos usuários.}
	\item{Disponibilizar os dados que devem ser apresentados nas telas da aplicação Web.}\cite{k19}	 	
	\end{itemize}}
	
	No Library Mapper existe dois grandes Managed Beans que cuidam das interfaces Web, o MapBean.java e o SearchBean.java, sendo que o 
	primeiro é responsável por toda a parte de criação da biblioteca e o segundo por todo o processo de busca, desde a requisição ao 
	Colméia até a geração do Mapa com o caminho.
	
	\subsubsection{JavaScript e jQuery}
	 JavaScript é uma linguagem de script baseada no padrão ECMAScript, aprovado como um padrão internacional ISO/IEC 16262, em abril de 1998,
	 utilizada para programação client-side em navegadores web.Foi inventada por Brendan Eich na Netscape e primeiro
	apareceu no navegador Navigator 2,0 da empresa . Ele já apareceu em todos os browsers Netscape subseqüentes e em todos os navegadores da Microsoft começando com Internet Explorer 
	3.0.\cite{javascript}\\

	{\it jQuery é uma biblioteca JavaScript rápida e concisa que simplifica num documento HTML o tratamento da manipulação de eventos, animação
	 e interações Ajax para desenvolvimento web rápido.}\cite{jquery} \\
	
	No Library Mapper o javaScript foi usado para criar métodos que ajudassem na lógica das interfaces e também para criar objetos
	semelhantes aos usados na parte JAVA, como no caso das estantes, qrCode e blocos livres e proibidos ao usuário passar.\\
	 
	O jQuery teve papel fundamental na parte responsável pela edição via Web do mapa da bilbioteca.Métodos como {\it resize}, {\it drag} e {\it drop}
	foram utilizados para possibilitar que um desses objetos javaScript descritos anteriormente se tornassem modeláveis através da interface Web.     

	\subsubsection{HTML5 - Canvas}
	{\it Hypertext Markup Language ou HTML é a linguagem de publicação da World Wide Web.}\cite{html}Atualmente na versão 5, o HTML
	possui novas funcionalidades e consegue realizar tarefas que antes só conseguia realizar através de outras ferramentas, como por exemplo
	carregar arquivos locais.\\

	Funcionando como um conteiner de processamento gráfico (gráfico de jogos, arte ou imagens) provê scripts para a renderização desses gráficos.
	Pode gerar qualquer tipo de forma, com qualquer tipo de cor, textura, etc e por isso, no Library Mapper é usado para gerar os mapas
	já com os caminhos mapeados, para o visitante que procuram por um livro.\\

	A classe responsável por esse script canvas é a CanvasMap.java que divide a criação do mapa em duas partes: Uma do carregamento do mapa
	 sem o caminho traçado da busca e outra para o desenho do resultado da busca.O primeiro caso é resolvido pelo método {\it loadNodesFromBD(StringBuilder out)} que verifica se
	a matriz Mapa(i,j) já foi carregada pelo Library Mapper, carregando ou não do banco de dados (dependendo da resposta) e transformando cada Node
	dessa matriz num quadrado colorido no mapa mostrado ao usuário.O parametro {\it out} passado é uma StringBuilder do JAVA, responsável por guardar o que será escrito no arquivo do mapa desenhado .xhtml.\\

	O segundo caso é resolvido pelo método {\it loadSearch(StringBuilder out, Book selectedBook)} que fica  responsável por extrair as posições de saída (QrCode - retirado da URL que iniciou a seção) e chegada (estante do livro - retirada do livro {\it selectedBook}) da procura pelo livro e por chamar a busca dessas posições.


      	\subsubsection{Desenvolvimento mobile}
	{\it As pessoas apreciam aplicativos iOS que sentem como se eles fossem projetados especificamente para o dispositivo. Por exemplo, quando um aplicativo se encaixa bem na tela do dispositivo e responde aos gestos que as pessoas conhecem, que fornece grande parte da experiência as quais as pessoas estão procurando. E, embora as pessoas possam não estar cientes dos princípios de design de interface humana, como a manipulação direta ou consistência, esses usuários podem dizer quando os aplicativos seguem esses princípios e quando não.Ao começar a projetar um aplicativo iOS, certifique-se de compreender e aprender como incorporar os princípios de design HI de modo que você possa oferecer ao usuário uma experiência pessoal que ele irá apreciar.}\cite{mobile}\\

	Inicialmente o Library Mapper foi desenvolvido apenas para se encaixar nos padrões IOS, especificamente para iPhones.Por isso toda sua interface e a maneira como o usuário opera o Library Mapper foi pensada para proporcionar uma experiência rápida e de fácil compreensão.Um exemplo é a página inicial de busca semelhante a usada pelo Google, que permite que o usuário reconheça facilmente que se trata de uma página de busca, pois já está familiarizado com o padrão.Outro exemplo é a idéia de um mapa ao invés de coordenadas descritivas como vire a esquerda na estante x, depois a direita, etc.Os botões estilizados para o toque e a lista de livros ocupando a tela inteira são outros exemplos também.
	\subsubsection{Integração Contínua}
	{\it	Integração Contínua é uma prática de desenvolvimento de software onde os membros de uma equipe integram seu trabalho frequentemente, geralmente cada pessoa integra pelo menos diariamente - levando a múltiplas integrações por dia. Cada integração é verificada por uma compilação automatizada (incluindo teste) para detectar erros de integração, o mais rapidamente possível.}\cite{ic}\\

	Por mais estranho que pareça falar de Integração Contínua para um time de uma única pessoa, chegou um ponto durante a criação do Library Mapper que essa técnica, ou parte dela, tornou-se essencial pois eu estava trabalhando nele em 3 lugares diferentes, com horários completamente diferentes de um dia para outro.Comecei a comitar tudo que eu fazia, indiferente se estava certo ou errado, pois assim conseguia continuar do ponto certo de onde parei.Também comecei a me policiar a tentar comitar algo todo dia, porque estava com o tempo muito restrito para desenvolver o projeto, afinal tinha que diviví-lo entre trabalho, casa recém comprada, faculdade e médico para meu futuro filho. 	   
   \subsection{Library Mapper, o cliente}
	Essa seção é reservada para explicar toda a parte relacionada ao cliente da aplicação e, nesse caso, o cliente é o responsável pela biblioteca.O único trabalho desse cliente é montar a biblioteca pela interface Web, identificando cada estante corretamente e onde ficarão os QR-Codes.
	Nessa primeira versão do Library Mapper, os qr-codes criados no programa são armazenados no banco de dados da aplicação e não há como identificá-los sem ter que olhar no BD pela ordem que foram criados.
	\subsubsection{Construindo o seu mapa Web} 
	
		Para a construção do mapa da biblioteca para o Library Mapper, existe uma interface Web que auxilia todo o processo de construção e identificação das estantes.Acessando http://host/LibraryMapper/faces/WebLibraryMapper/mapCreation.xhtml uma tela com um espaço definido para construção junto de todos acessórios para montagem do mapa aparecerão, como mostrado na figura  \ref{mapCreation}.\\

	Desses acessórios existe um botão Save para salvar o mapa no Banco de dados e quatro objetos para montagem da biblioteca:
\begin{figure}[H]
	\centering
	\includegraphics[width=0.90\textwidth]{./imgs/mapCreation.png}\\[1cm]   
	\caption{Interface Web para criação de mapas.}
	\label{mapCreation}
\end{figure}	

\begin{itemize}	
	\item{{\bf Background  }}\\
		O objeto background deve ser utilizado para montar o chão da biblioteca, ou seja, é a base da biblioteca e tudo deve ser montado em cima dele.Uma vez o mapa transformado na matriz utilizada pelo Library Mapper, a parte do Background que não possua nada em cima será definida como um Node do tipo Free. 	
	\item{{\bf Qr Code  }}\\	
		O objeto Qr Code deve ser colocado na mesma posição onde será colocado na biblioteca física, pois senão o usuário encontrará problemas para se orientar no mapa.Uma vez o mapa transformado na matriz utilizada pelo Library Mapper, cada parte do QrCode gerado será um Node do tipo QrCode. 	
	\item{{\bf Forbidden  }}\\
		O objeto Forbidden deve ser enterpretado, com exceção das estantes, como qualquer obstáculo existente na biblioteca: vasos, colunas, esculturas, ou seja, qualquer coisa que impeça o usuário de passar por aquele espaço específico.Uma vez o mapa transformado na matriz utilizada pelo Library Mapper, cada parte do Forbidden gerado será um Node do tipo Forbidden.	
	\item{{\bf BookShelf }}\\
		O objeto BookShelf deve ser enterpretado como {\bf uma parte da estante} física, ou a estante inteira, dependendo dos livros que ela possui.Uma estante é definida por dois identificadores, sendo um de início referente ao primeiro livro da estante e um de fim, referente ao último livro da estante.No caso da biblioteca do IME-USP a identificação é feita dessa maneira e começa no topo esquerdo da estante e termina no piso direito da mesma, como mostrado na figura \ref{estante}.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.60\textwidth]{./imgs/estanteIME.png}\\[1cm]   
	\caption{Referencia a organização de uma estante na biblioteca IME-USP}
	\label{estante}
\end{figure}

Caso uma estante seja um conjunto de livros do mesmo prefixo, então tem-se uma estante inteira igual a estante física como na figura \ref{variasEstantes}.b, porém caso existam vários tipos de conjuntos de prefixos devem ser criadas n estantes do Library Mapper, onde n é o número de conjuntos contidos na estante física, como mostrado na figura \ref{variasEstantes}.a.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.80\textwidth]{./imgs/estantes.png}\\[1cm]   
	\caption{A figura (a) mostra uma estante física dividida em várias estantes do Library Mapper enquanto a figura (b)
	mostra apenas uma única estante.}
	\label{variasEstantes}
\end{figure}

 	Essa interpreteção é importante porque dado que o mapa é definido numa superfície 2D não existe outra maneira de separar grupos diferentes de livros numa mesma estante, a não ser colocando uns do lado dos outros.
	\end{itemize}
	
	\subsubsection{Transformação do JavaScript para Nodes}
	\subsubsection{Salvando no Banco de Dados}
   \subsection{Library Mapper, o usuário}
	\subsubsection{Identificando o usuário}
	\subsubsection{A consulta e a ligação com a biblioteca}
	\subsubsection{Lista de livros e a busca pela estante}
	\subsubsection{Montando o mapa com HTML5 e canvas}
   \subsection{Atividades realizadas}
	
   \subsection{Resultados e produtos obtidos}
   \subsection{Conclusões}

   
  \section{Parte Subjetiva}
  \subsection{Desafios e frustrações}
  \subsection{Relações entre Disciplinas}
  \subsection{Os próximos passos}
  
\bibliographystyle{plain}   
\bibliography{refer}  
\end{document}


